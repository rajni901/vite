"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deploy = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const form_data_1 = tslib_1.__importDefault(require("form-data"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const js_yaml_1 = tslib_1.__importDefault(require("js-yaml"));
const path_1 = tslib_1.__importDefault(require("path"));
const picomatch_1 = tslib_1.__importDefault(require("picomatch"));
const tar_1 = tslib_1.__importDefault(require("tar"));
const tmp_1 = tslib_1.__importDefault(require("tmp"));
const _config_1 = require("@config");
const auth_1 = require("@common/auth");
const defaultIgnore = [
    '.git',
    '.gitmodules',
    '.vscode',
    '.next',
    '.npm',
    '.venv',
    '.yarn',
    '__pycache__',
    'bin',
    'dist',
    'node_modules',
    'yarn-error.log',
    '.DS_Store',
];
const deploy = (program) => {
    program
        .command('deploy')
        .description('Deploy a script')
        .action(async function () {
        const debug = this.opts().debug;
        const authed = await (0, auth_1.setAuthHeader)({ debug });
        if (!authed) {
            return;
        }
        const tokens = await (0, auth_1.getTokens)({ debug });
        const { access_token } = tokens;
        // get current directory
        const cwd = process.cwd();
        debug && console.log(`Current directory: ${cwd}`);
        let folderToCheck = cwd;
        let hasConfig = false;
        // check each parent folder for a village.yaml file
        while (folderToCheck !== '') {
            debug &&
                console.log(`Checking ${folderToCheck} for village.yaml`);
            const configPath = `${folderToCheck}/village.yaml`;
            if (fs_1.default.existsSync(configPath)) {
                debug &&
                    console.log(`Found village.yaml in ${folderToCheck}`);
                hasConfig = true;
                break;
            }
            const nextParent = folderToCheck
                .split(path_1.default.sep)
                .slice(0, -1) // remove last folder
                .join(path_1.default.sep);
            if (nextParent === folderToCheck) {
                break;
            }
            folderToCheck = nextParent;
        }
        if (!hasConfig) {
            console.error('No village.yaml file found. Run "village init" to create one');
            return;
        }
        const baseFolder = folderToCheck;
        let ignoreContents;
        try {
            ignoreContents = fs_1.default
                .readFileSync(`${baseFolder}{path.sep}.villageignore`, 'utf8')
                .split('\n');
        }
        catch (err) {
            debug && console.log('No .villageignore file found');
            ignoreContents = [];
        }
        // picomatch breaks on empty strings
        ignoreContents = ignoreContents.filter((line) => line.length > 0);
        // split ignored files into array
        const ignoredFiles = [...defaultIgnore, ...ignoreContents];
        const nonnegated = ignoredFiles.filter((file) => !file.startsWith('!'));
        const negated = ignoredFiles
            .filter((file) => file.startsWith('!'))
            .map((file) => file.slice(1)); // remove the !
        const nonnegatedMatcher = (0, picomatch_1.default)(nonnegated);
        const negatedMatcher = (0, picomatch_1.default)(negated);
        const configFilePath = `${baseFolder}${path_1.default.sep}village.yaml`;
        const configContents = fs_1.default.readFileSync(configFilePath, 'utf8');
        const config = js_yaml_1.default.load(configContents);
        const tmpFile = tmp_1.default.fileSync();
        debug &&
            console.log(`Created temporary file ${tmpFile.name} for tarball`);
        await tar_1.default.c({
            gzip: true,
            file: tmpFile.name,
            filter: (name) => {
                const keep = !nonnegatedMatcher(name) || negatedMatcher(name);
                debug &&
                    console.log(`${name} ${keep ? 'keep' : 'ignore'}`);
                return keep;
            },
        }, ['./']);
        const form = new form_data_1.default();
        form.append('script_id', config.id);
        form.append('context', fs_1.default.createReadStream(tmpFile.name));
        // use a raw axios request because openapi-generator doesn't like streams
        axios_1.default
            .post(`${_config_1.API_BASE_URL}/script/build`, form, {
            headers: Object.assign(Object.assign({}, form.getHeaders()), { Authorization: `Bearer ${access_token}` }),
        })
            .then((res) => {
            console.log('Script deployed successfully');
            console.log(tmpFile.name);
            // delete the temporary file
            tmpFile.removeCallback();
        })
            .catch(auth_1.warnUnauthenticated)
            .catch((err) => {
            if (err.response.status === 404) {
                const relativeConfigPath = path_1.default.relative(cwd, configFilePath);
                console.log(`Script with id '${config.id}' does not exist!`);
                console.log(`Create it by running 'village init --from ${relativeConfigPath}' first!`);
            }
            if (err.response.status === 403) {
                console.log(`You do not have permission to deploy script with id '${config.id}'`);
            }
            debug && console.log(err);
            // delete the temporary file
            tmpFile.removeCallback();
        });
    });
};
exports.deploy = deploy;
//# sourceMappingURL=deploy.js.map